name: Apply God Mode SOTA Fixes

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  apply-fixes:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Apply fixes using Node script
        run: |
          node << 'SCRIPT'
          const fs = require('fs');
          const path = './src/services.tsx';
          let content = fs.readFileSync(path, 'utf8');
          
          // Fix 1: Replace getPrioritizedPages method
          const oldMethod = /private async getPrioritizedPages\(context: GenerationContext\): Promise<SitemapPage\[\]> \{[\s\S]*?return \[\.\.\.prioritized, \.\.\.rest\];[\s\S]*?\}/m;
          
          const newMethod = `private async getPrioritizedPages(context: GenerationContext): Promise<SitemapPage[]> {
              const now = Date.now();
              const targetUrls = this.getUserTargetUrls();
              const targetNormSet = new Set(targetUrls.map(u => this.normalizeUrl(u)));
              
              const isTarget = (p: SitemapPage) => targetNormSet.has(this.normalizeUrl(p.id));
              
              const candidates = [...context.existingPages].filter(p => {
                  if (isTarget(p)) return true;
                  const lastProcessed = localStorage.getItem(\`sota_last_proc_\${p.id}\`);
                  if (!lastProcessed) return true;
                  const hoursSince = (now - parseInt(lastProcessed, 10)) / (1000 * 60 * 60);
                  return hoursSince > 24;
              });
              
              const byNorm = new Map(candidates.map(p => [this.normalizeUrl(p.id), p] as const));
              const prioritized: SitemapPage[] = [];
              const used = new Set<string>();
              
              for (const url of targetUrls) {
                  const norm = this.normalizeUrl(url);
                  const page = byNorm.get(norm) || {
                      id: url,
                      title: url,
                      slug: extractSlugFromUrl(url),
                      lastMod: null,
                      wordCount: null,
                      crawledContent: null,
                      healthScore: null,
                      updatePriority: 'Critical',
                      justification: 'User-selected target URL (URL Targeting Engine).',
                      daysOld: 999,
                      isStale: true,
                      publishedState: 'none',
                      status: 'idle',
                      analysis: null
                  };
                  
                  if (!used.has(norm)) {
                      used.add(norm);
                      prioritized.push(page as SitemapPage);
                  }
              }
              
              const rest = candidates
                  .filter(p => !used.has(this.normalizeUrl(p.id)))
                  .sort((a, b) => (b.daysOld || 0) - (a.daysOld || 0));
              
              this.logCallback(\`üéØ Targets loaded: \${targetUrls.length}. Queue size: \${prioritized.length + rest.length}\`);
              return [...prioritized, ...rest];
          }`;
          
          content = content.replace(oldMethod, newMethod);
          
          // Fix 2: Add references injection before updatedHtml
          const referencesInjection = `
          // SOTA: Inject verified references
          try {
              const existing = body.querySelector('.sota-references-section');
              if (existing) existing.remove();
              const referencesHtml = await fetchVerifiedReferences(page.title, context.serperApiKey, wpConfig.url);
              if (referencesHtml) {
                  const wrap = doc.createElement('div');
                  wrap.innerHTML = referencesHtml;
                  body.appendChild(wrap);
                  this.logCallback('‚úÖ References added');
              }
          } catch (e: any) {
              this.logCallback(\`‚ö†Ô∏è References failed: \${e?.message}\`);
          }
          
          const updatedHtml = body.innerHTML;`;
          
          content = content.replace(
              /const updatedHtml = body\.innerHTML;/,
              referencesInjection
          );
          
          fs.writeFileSync(path, content, 'utf8');
          console.log('‚úÖ Fixes applied successfully!');
          SCRIPT
          
      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src/services.tsx
          
          # Check if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Commit changes
          git commit -m "fix: God Mode targets-first + verified references injection"
          
          # Pull and rebase to sync with remote
          git pull --rebase origin main
          
          # Push changes
          git push
